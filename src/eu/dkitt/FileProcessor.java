package eu.dkitt;

import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.OutputStream;
import java.nio.file.FileSystems;
import java.nio.file.FileVisitOption;
import java.nio.file.FileVisitResult;
import java.nio.file.Path;
import java.nio.file.PathMatcher;
import java.nio.file.SimpleFileVisitor;
import java.nio.file.FileVisitor;
import java.nio.file.Files;
import java.nio.file.attribute.BasicFileAttributes;
import java.util.EnumSet;
import java.util.Properties;

public class FileProcessor implements FileVisitor<Path> {
	
	private int outFileCounter = 1;
	
	private byte [] outbuf = new byte[100000];
	private int out_index = 0;
	
	public void prepareForNextFile() {
		out_index = 0;
	}
	
	public void	addOneFrame(byte [] bytes, int n){
		for(int i=0; i<n; ++i) {
			outbuf[out_index + i] = bytes[i];
		}
		out_index += n;
	}
	
	public	void	commitFile() throws FileNotFoundException, IOException {
		String fileName = String.format(fileRcvdFmt, outFileCounter);
		Path path = fileRcvd.resolve(fileName);
		System.out.println("path = " + path);
		
		try(OutputStream os = new FileOutputStream(path.toFile()) ){
			os.write(outbuf, 0, out_index);
			os.close();
			outFileCounter++;
		}
	}
	
	private final Properties properties;
	private Path file = null;
	EnumSet<FileVisitOption> opts;
	
	/** Search directory with files to send */
	private final Path fileStart;
	
	/** Search mask for files to send */
	private final PathMatcher matcher;
	
	/** Directory where to move send files */
	private final Path fileBackup;
	
	/** Directory where to write received files */
	private final Path fileRcvd;
	
	/** Format of filenames generated by receiver */
	private final String fileRcvdFmt;
	
	public FileVisitResult visitFile(Path file, BasicFileAttributes attr) {
		if (attr.isRegularFile()) {
			if(matcher.matches(file)){
				this.file = file;
				return FileVisitResult.TERMINATE;
			}
		}
		return FileVisitResult.CONTINUE;
	}
	
	public	FileProcessor(Properties properties) {
		String directory;
		String mask;
		this.properties = properties;
		opts = EnumSet.noneOf(FileVisitOption.class);
		directory = this.properties.getProperty(T1.OPTION_DIRECTORY_2_SEND);
		fileStart = FileSystems.getDefault().getPath(directory);
		mask = this.properties.getProperty(T1.OPTION_FILES_2_SEND_MASK);
		matcher = FileSystems.getDefault().getPathMatcher("glob:" + mask);
		directory = this.properties.getProperty(T1.OPTION_DIRBACKUP_2_SEND);
		fileBackup = FileSystems.getDefault().getPath(directory);
		directory = this.properties.getProperty(T1.OPTION_DIRECTORY_RCVD);
		fileRcvd = FileSystems.getDefault().getPath(directory);
		fileRcvdFmt = this.properties.getProperty(T1.OPTION_FILES_RCVD_NAME);
	}
	
	public	boolean	hasFileToSend() {
		file = null;
		try {
			Files.walkFileTree(fileStart, opts, 1, this);
		} catch (IOException e) {
			file = null;
		}
		return file != null;
	}
	
	public Path getFile() {
		return file;
	}

	@Override
	public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
		return FileVisitResult.CONTINUE;
	}

	@Override
	public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
		return FileVisitResult.CONTINUE;
	}

	@Override
	public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
		return FileVisitResult.CONTINUE;
	}
	
}
